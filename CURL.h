// Header Files
#include <curl/curl.h>
#include <curl/easy.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Print Colors
#define RED(string)     "\x1b[31m" string "\x1b[0m"
#define GREEN(string)   "\x1b[32m" string "\x1b[0m"
#define YELLOW(string)  "\x1b[33m" string "\x1b[0m"
#define BLUE(string)    "\x1b[34m" string "\x1b[0m"
#define MAGENTA(string) "\x1b[35m" string "\x1b[0m"
#define CYAN(string)    "\x1b[36m" string "\x1b[0m"


// Struct To Read Responses 
struct resp {
  char *response;
  size_t size;
};

// Struct To Contain Flags About Server
struct SERVER_INFO{
  int VULN_VERSION;
  int IS_VULN;
  int SSL_MODE;
  char *RESPONSE;
};

struct SERVER_INFO SERVER;

// Global Struct
static inline void INIT_SERVER()
{
  SERVER.VULN_VERSION=0;
  SERVER.IS_VULN=0;
  SERVER.SSL_MODE=0;
  SERVER.RESPONSE=malloc(1);
  SERVER.RESPONSE[0]='\0';
}

// Check Headers To Check If Given Version Is Vulnerable
static inline size_t CHECK_HEADERS(char *buffer, size_t itemsize, size_t nitems, void* ign)
{
  size_t bytes=itemsize*nitems;

  fprintf(stdout,GREEN("%s"),buffer);
  if (strstr(buffer,"Server:")!=NULL)
  {
    //Check If The Version Of Miniserv Is Vulnerable
    if ((strstr(buffer,"MiniServ/1.890")!=NULL) || (strstr(buffer,"MiniServ/1.900")!=NULL) || (strstr(buffer,"MiniServ/1.910")!=NULL) || (strstr(buffer,"MiniServ/1.920")!=NULL))
    {
        SERVER.VULN_VERSION=1;
    }
  }
  return bytes;
}

static inline size_t GET_RESP(void *ptr, size_t size, size_t nmemb, struct resp *s)
{
  return 0;
}

// Fetch Version Information
static inline int CHECK_VERSION(char *url)
{
  CURLcode ret;
  CURL *hnd;

  hnd = curl_easy_init();
  if (!hnd){
    fprintf(stderr,"[-]" RED("Curl init failed") "\n");
    return EXIT_FAILURE;
  }
    
  curl_easy_setopt(hnd, CURLOPT_BUFFERSIZE, 102400L);
  curl_easy_setopt(hnd, CURLOPT_URL, url);
  curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);
  curl_easy_setopt(hnd, CURLOPT_NOBODY, 1L);
  curl_easy_setopt(hnd, CURLOPT_USERAGENT, "curl/7.74.0");
  curl_easy_setopt(hnd, CURLOPT_FOLLOWLOCATION, 1L);
  curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);
  curl_easy_setopt(hnd, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_2TLS);
  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYPEER, 0L);
  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYHOST, 0L);
  curl_easy_setopt(hnd, CURLOPT_FILETIME, 1L);
  curl_easy_setopt(hnd, CURLOPT_FTP_SKIP_PASV_IP, 1L);
  curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);
  curl_easy_setopt(hnd, CURLOPT_HEADERFUNCTION, CHECK_HEADERS);
  curl_easy_setopt(hnd, CURLOPT_WRITEFUNCTION, GET_RESP);
  
  ret = curl_easy_perform(hnd);
  if (ret != CURLE_OK)
  {
    fprintf(stderr,"[-] Curl Returned Error As: " RED("%s") "\n",curl_easy_strerror(ret));
  }

  curl_easy_cleanup(hnd);
  hnd = NULL;

  return (int)ret;
}
