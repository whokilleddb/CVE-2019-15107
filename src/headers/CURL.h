// Header Files
#include <curl/curl.h>
#include <curl/easy.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../structs/structs.h"

// Print Colors
#define RED(string)     "\x1b[31m" string "\x1b[0m"
#define GREEN(string)   "\x1b[32m" string "\x1b[0m"
#define YELLOW(string)  "\x1b[33m" string "\x1b[0m"
#define BLUE(string)    "\x1b[34m" string "\x1b[0m"
#define MAGENTA(string) "\x1b[35m" string "\x1b[0m"
#define CYAN(string)    "\x1b[36m" string "\x1b[0m"

// Global Variable
struct SERVER_INFO SERVER;
char *URL;

// Initialise Global Variables
static inline void INIT_SERVER(char *url)
{
  SERVER.VULN_VERSION=0;
  SERVER.IS_VULN=0;
  SERVER.SSL_MODE=0;
  SERVER.RESPONSE.len=0;
  SERVER.RESPONSE.ptr=malloc(SERVER.RESPONSE.len+1);
  if(SERVER.RESPONSE.ptr == NULL)
  {
    fprintf(stderr, "[-] "RED("malloc() Failed!" "\n"));
    exit(EXIT_FAILURE);
  }
  SERVER.RESPONSE.ptr[0] = '\0';
  URL = (char *)malloc(strlen(url)+1);
  if (URL == NULL)
  {
    fprintf(stderr, "[-] "RED("malloc() Failed!" "\n"));
    exit(EXIT_FAILURE);
  }
  strcpy(URL,url);
}


// Check Headers To Check If Given Version Is Vulnerable
static inline size_t CHECK_HEADERS(char *buffer, size_t itemsize, size_t nitems, void* ign)
{
  size_t bytes=itemsize*nitems;

  fprintf(stdout,GREEN("%s"),buffer);
  if (strstr(buffer,"Server:")!=NULL)
  {
    //Check If The Version Of Miniserv Is Vulnerable
    if ((strstr(buffer,"MiniServ/1.890")!=NULL) || (strstr(buffer,"MiniServ/1.900")!=NULL) || (strstr(buffer,"MiniServ/1.910")!=NULL) || (strstr(buffer,"MiniServ/1.920")!=NULL))
    {
        SERVER.VULN_VERSION=1;
    }
  }
  return bytes;
}

// Get Response Of The Complete Request
static inline size_t GET_RESP(void *ptr, size_t size, size_t nmemb, struct chunck *s)
{
  size_t new_len = s->len + size*nmemb;
  s->ptr = realloc(s->ptr, new_len+1);
  if (s->ptr == NULL) 
  {
    fprintf(stderr, "[-] "RED("realloc() Failed!" "\n"));
    exit(EXIT_FAILURE);
  }
  memcpy(s->ptr+s->len, ptr, size*nmemb);
  s->ptr[new_len] = '\0';
  s->len = new_len;

  return size*nmemb;
}

// Check If Server Is Running In SSL Mode
static inline void CHECK_SSL_MODE()
{
  if (strstr(SERVER.RESPONSE.ptr,"server is running in SSL mode")!=NULL)
  {
    SERVER.SSL_MODE=1;
  }
}

// Fetch Version Information
static inline int CHECK_VERSION()
{
  CURLcode ret;
  CURL *hnd;

  hnd = curl_easy_init();
  if (!hnd){
    fprintf(stderr,"[-]" RED("Curl init failed") "\n");
    return EXIT_FAILURE;
  }
    
  curl_easy_setopt(hnd, CURLOPT_BUFFERSIZE, 102400L);
  curl_easy_setopt(hnd, CURLOPT_URL, URL);
  curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);
  curl_easy_setopt(hnd, CURLOPT_USERAGENT, "curl/7.74.0");
  curl_easy_setopt(hnd, CURLOPT_FOLLOWLOCATION, 1L);
  curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);
  curl_easy_setopt(hnd, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_2TLS);
  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYPEER, 0L);
  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYHOST, 0L);
  curl_easy_setopt(hnd, CURLOPT_FTP_SKIP_PASV_IP, 1L);
  curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);
  curl_easy_setopt(hnd, CURLOPT_WRITEFUNCTION, GET_RESP);
  curl_easy_setopt(hnd, CURLOPT_WRITEDATA, &SERVER.RESPONSE);
  curl_easy_setopt(hnd, CURLOPT_HEADERFUNCTION, CHECK_HEADERS);
  
  ret = curl_easy_perform(hnd);
  if (ret != CURLE_OK)
  {
    fprintf(stderr,"[-] Curl Returned Error As: " RED("%s") "\n",curl_easy_strerror(ret));
  }
  CHECK_SSL_MODE();
  free(SERVER.RESPONSE.ptr);
  curl_easy_cleanup(hnd);
  hnd = NULL;

  return (int)ret;
}
